<!DOCTYPE html>
<html lang="en">
  <html>
    <head>
      <title>SU CS CPSC-2430</title>
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
        rel="stylesheet"
      />
      <link rel="stylesheet" href="main.css" type="text/css" />
      <link
        rel="icon"
        href="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Seattle_Redhawks_logo.svg/1200px-Seattle_Redhawks_logo.svg.png"
      />
    </head>
    <body>
      <header>
        <!--<a href="https://1chipp.github.io/project3700.github.io/index.html">
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Seattle_Redhawks_logo.svg/1200px-Seattle_Redhawks_logo.svg.png"
        width="4%">
      </a>
      <h1>SU Computer Science Help Center</h1>-->
        <nav class="navbar navbar-expand-lg" style="background-color: #282828">
          <div class="container-fluid">
            <a class="navbar-brand" href="#"
              ><img
                src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Seattle_Redhawks_logo.svg/1200px-Seattle_Redhawks_logo.svg.png"
                width="50px"
            /></a>
            <button
              class="navbar-toggler"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#navbarSupportedContent"
              aria-controls="navbarSupportedContent"
              aria-expanded="false"
              aria-label="Toggle navigation"
            >
              <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
              <div class="navbar-nav">
                <a class="nav-link" href="https://1chipp.github.io/project3700.github.io/index.html">Home</a>
                <a
                  class="nav-link"
                  href="https://1chipp.github.io/project3700.github.io/practice.html"
                  >Practice Problems</a
                >
                <a
                  class="nav-link"
                  id="current"
                  href="https://1chipp.github.io/project3700.github.io/classes.html"
                  >Classes</a
                >
                <a
                  class="nav-link"
                  href="https://1chipp.github.io/project3700.github.io/contact.html"
                  >Contact</a
                >
                <a
                  class="nav-link"
                  href="https://www.seattleu.edu/scieng/computer-science/student-resources/"
                  target="_blank"
                  >Student Resources</a
                >
              </div>
            </div>
          </div>
        </nav>
        <!--<nav>
        <ul>
          <li><a href="https://1chipp.github.io/project3700.github.io/practice.html">Practice Problems</a></li>
          <li><a href="https://1chipp.github.io/project3700.github.io/classes.html">Classes</a></li>
          <li><a href="https://1chipp.github.io/project3700.github.io/index.html">Home</a></li>
          <li><a href="https://www.seattleu.edu/scieng/computer-science/student-resources/" target="_blank">Student Resources</a></li>
          <li><a href="https://www.seattleu.edu/about/contact/" target="_blank">Contact</a></li>
        </ul>
      </nav>-->
      </header>
      <section>
        <h1>CPSC 2430: Data Structures: 5 credit class</h1>
        <h2>About</h2>
        <p>
          Fundamental data structures including binary search trees, priority queues, hash tables, and heaps.  
          Abstract data type implementation and design. Code analysis using big-O notation, recursion, and sorting algorithms.</p>
      </section>
      <section>
        <h2>Prerequisites</h2>
        <p>
          Take CPSC-1230 or CPSC-1430; Minimum grade C; - Must be completed prior to taking this course.
        </p>
      </section>
      <section>
        <h2>Learning Outcomes</h2>
        <p>
          • Analyze the runtime performance of code segments and data structure operations using
          big-O notation. <br>
          • Implement recursive solutions to problems, properly identifying base case(s) and recursive
          relations. <br>
          • Implement recursive and non-recursive algorithms to manipulate binary search trees,
          heaps, and priority queues; use them appropriately in solving problems. <br>
          • Implement algorithms to manipulate hash tables and use them appropriately in solving
          problems. <br>
          • Compare and contrast sorting algorithms, including quicksort, mergesort, and heapsort. <br>
        </p>
      </section>
      <section>
        <h2>Big-O Notation</h2>
        <button onclick="myFunction('boDefinition')">Definition</button>
        <div id="boDefinition" class="myClass">
          <strong>Big O notation</strong> is a mathematical notation used to describe the upper bound of an algorithm's running time or space complexity in terms of the input size.<br>
          It provides an asymptotic analysis, focusing on the behavior of the algorithm as the input size grows towards infinity.<br><br>
          This notation helps in comparing the efficiency of different algorithms by providing a high-level understanding of their performance characteristics.<br><br>
          O(1): Constant time. The running time or space required does not change with the size of the input. Example: Accessing an element in an array by index.<br><br>
          O(log n): Logarithmic time. The running time grows logarithmically with the input size. Example: Binary search in a sorted array.<br><br>
          O(n): Linear time. The running time grows linearly with the input size. Example: Iterating through an array.<br><br>
          O(n log n): Linearithmic time. The running time grows linearly with a logarithmic factor. Example: Efficient sorting algorithms like mergesort and heapsort.<br><br>
          O(n^2): Quadratic time. The running time grows quadratically with the input size. Example: Simple sorting algorithms like bubble sort, selection sort, and insertion sort.<br><br>
          O(2^n): Exponential time. The running time grows exponentially with the input size. Example: Solving the Traveling Salesman Problem using a brute-force approach.<br><br>
          O(n!): Factorial time. The running time grows factorially with the input size. Example: Generating all permutations of a set.
        </div>
        <button onclick="myFunction('boExamples')">Importance</button>
        <div id="boExamples" class="myClass">
          Predict Performance: It helps in predicting the performance of an algorithm as the input size grows.<br><br>
          Compare Algorithms: It provides a standard way to compare the efficiency of different algorithms.<br><br>
          Identify Bottlenecks: It helps in identifying parts of an algorithm that could be optimized for better performance.<br><br>
          Scalability: It gives an understanding of how well an algorithm scales with larger datasets.<br><br>
        </div>
      </section>
      <section>
        <h2>Recursion</h2>
        <button onclick="myFunction('recDefinition')">Definition</button>
        <div id="recDefinition" class="myClass">
          <strong>Recursion</strong> in computer science, including data structures, refers to a process where a function calls itself in order to solve a smaller instance of the same problem.<br><br>
          In the context of data structures, recursion often involves algorithms that traverse or manipulate recursive data structures, such as trees and graphs.<br><br>
          <strong>Characteristics of Recursive Functions</strong><br>
          Base Case: A condition that stops the recursion by providing an exit point. Without a base case, the recursion would continue indefinitely, leading to a stack overflow.<br>
          Recursive Case: The part of the function that makes the recursive call to solve a smaller instance of the problem. This typically involves breaking down the problem into smaller subproblems.<br>
          Call Stack: Recursion uses the call stack to keep track of function calls. Each recursive call adds a new frame to the call stack, and when the base case is reached, the stack unwinds, and the function returns control back to the caller.
        </div>
        <button onclick="myFunction('recExamples')">Example</button>
        <div id="recExamples" class="myClass">
          A common example of recursion in data structures is tree traversal, where a function visits each node of a tree in a specific order. There are three primary methods of tree traversal: in-order, pre-order, and post-order.<br>
        </div>
      </section>
      <section>
        <h2>Binary Search Trees</h2>
        <button onclick="myFunction('bstDefinition')">Definition</button>
        <div id="recDefinition" class="myClass">
          A <strong>binary search tree (BST)</strong> is a binary tree data structure where each node has at most two children (left and right), and the key (value) of each node is greater than all keys in its left subtree and less than all keys in its right subtree.<br><br> 
          This ordering property allows for efficient searching, insertion, and deletion operations, making binary search trees a fundamental data structure in computer science.<br><br>
          <strong>Characteristics of Binary Search Trees</strong><br>
          Binary Tree Structure: Each node in a BST has at most two children: a left child and a right child.<br>
          Ordering Property: The key of each node is greater than all keys in its left subtree and less than all keys in its right subtree.<br>
          This property ensures that the tree remains ordered, facilitating efficient searching operations.<br><br>
          <strong>Operations on Binary Search Trees</strong><br>
          Search: Find a given key in the binary search tree.<br>
          Insertion: Add a new key to the binary search tree while maintaining the binary search tree properties.<br>
          Deletion: Remove a key from the binary search tree while preserving the binary search tree properties.<br>
          Traversal: Visit all nodes of the binary search tree in a specific order. Common traversal methods include in-order, pre-order, and post-order traversals.
        </div>
        <button onclick="myFunction('bstExamples')">Example</button>
        <div id="recExamples" class="myClass">
          In this BST, if we use a 1-based indexing scheme and store the nodes in an array, it would look like this:<br>
          [10, 5, 20, 3, 8, 15, 25]<br>
          Here, the root node (10) is stored at index 0, its left child (5) at index 1, its right child (20) at index 2, and so on.
        </div>
      </section>
      <section>
        <h2>Priority Queues</h2>
        <button onclick="myFunction('qDefinition')">Definition</button>
        <div id="qDefinition" class="myClass">
          A <strong>priority queue</strong> is an abstract data type that operates similar to a regular queue or stack, but with an additional priority associated with each element.<br><br>
          In a priority queue, elements are stored based on their priority, and elements with higher priority are dequeued before elements with lower priority.
        </div>
        <button onclick="myFunction('qExamples')">Example</button>
        <div id="qExamples" class="myClass">
          Shortest Path Algorithms: Used in Dijkstra's algorithm to find the shortest path in a graph.<br><br>
          Scheduling Algorithms: Used in job scheduling to process tasks based on priority.<br><br>
          Huffman Coding: Used in data compression algorithms to encode characters based on their frequency of occurrence.<br><br>
          Event-driven Simulation: Used in discrete event simulation to schedule and process events based on their occurrence time.
        </div>
      </section>
      <section>
        <h2>Hash Tables</h2>
        <button onclick="myFunction('Definition')">Definition</button>
        <div id="Definition" class="myClass">
          A <strong>hash table</strong> is a data structure that stores key-value pairs, allowing for efficient insertion, deletion, and retrieval of elements based on their keys.<br><br>
          Hash tables use a hash function to compute an index (also known as a hash code) into an array of buckets or slots, where each bucket may contain one or more key-value pairs.
        </div>
      </section>
      <section class=>
        <h2 class="text-center my-5" id="homeh2">Helpful Resources</h2>
        <div class="container">
          <div class="row">
            <div class="col-sm-4">
              <div class="card">
                <a href="https://www.amazon.com/Data-Structures-Algorithm-Analysis-C/dp/013284737X">
                <img src="https://1chipp.github.io/project3700.github.io/Images/dtsbook.jpg" class="card-img-top" alt="...">
                <div class="card-body">
                  <p class="card-text">Data Structures and Algorithm Analysis in C++</p>
                </div>
                </a>
              </div>
            </div>
          </div>
        </div>
      </section>
      <footer>
      <a href="https://www.seattleu.edu/scieng/computer-science/activities/" target="_blank">News</a> | 
      <a href="https://1chipp.github.io/project3700.github.io/contact.html"> Contact Us </a> | 
      <a href="https://www.seattleu.edu/scieng/computer-science/" target="_blank"> Information </a>|
      <a href="https://www.seattleu.edu/scieng/computer-science/student-resources/" target="_blank">Student Resources </a>| 
      <a href="https://catalog.seattleu.edu/preview_program.php?catoid=51&poid=10568" target="_blank">General Requirements</a>
    </footer>
      <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
      <script src="scroll.js"></script>
      <script src="display.js"></script>
    </body>
  </html>
</html>
